#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include"lexerDef.h"
#include"parserDef.h"
#include"lexer.h"
#include"parser.h"

main(int argc, char* argv[]) {
       int yourOption;
/*     printf("BATCH 22: 1. VAMSI TADIKONDA (2013A7PS039P) \n");
     printf("    (a) FIRST and FOLLOW set not automated. \n    (b) Both lexical and syntax analysis modules implemented. \n    (c) modules work perfectly with all testcases and written some test cases for syntactic analysis as well. \n    (d) parse tree constructed. \n \n");
     printf("Press option for the defined task :\n");
     printf("    1 :   For removal of comments - print the comment free code on the console. \n");
     printf("    2 :   For printing the token list (on the console) generated by the lexer. \n");
     printf("    3 :   For parsing to verify the syntactic correctness of the input source code.\n");
     printf("    4 :   For creating the parse tree and printing it appropriately. \n");
     printf("    5 :   For printing the grammar.\n");
 */    printf("Your Option:");
     scanf("%d",&yourOption);
     printf("\n");
     if(yourOption<=5 && yourOption>=1)
     {
//****************** INTERFACE***************************************

  int start=0 ; int stop=0 ; int line =1 ;
  FILE *fp;
  fp = fopen(argv[1],"r");
   if(fp==NULL)
   {
     printf("Error in Opening Testfile. \n Press Enter Continue:\n");
     char day ;
     while(day!='\n')
      day= getchar();
      exit(0);
   }
   buffer B;
     B.size=0;
     HTABLE t;
     int y=0;
     for(y=0;y<30;y++) {
	t.ent[y] = (ENTRY *) malloc(sizeof(ENTRY)) ;
	}
     populateTable(&t);
     getStream(fp,&B,100000);
     
      TOKEN ERROR;
      ERROR.tkno=-100;
    if(yourOption==1)
    {
       commentfreecode(&B);
    }
    else if(yourOption==5)
    {
       struct grammar G1;
       loadGrammar(&G1,"grammar.txt") ;        
       printGrammar(&G1); 
    }    
    else 
    {
        int errorfound=0;  
	TOKEN* temp1 = NULL;
       while ( stop < B.size  ) {
        temp1=(TOKEN*)getNextToken(&t, &B,&start,&stop,&line,&ERROR);
	  
         if(temp1==&ERROR)
           { errorfound=1;  start=stop ;}
	 else if(temp1==NULL && B.buff[start]==EOF)
            {
                break;        
            }

         else  start=stop ;
        }
        if(errorfound==1)
	 {printf("\n \n Resolve the Lexical Errors!! \n \n");}
        else
	{
           if(yourOption == 2)
        	printall();
      	   else
	   {
           	struct table why;
          	 int g1=0,h1=0;
       		 for(g1=0;g1<50;g1++)
        	{
            		for(h1=0;h1<57;h1++)
            		{why.ParseTable[g1][h1] = 100;}
        	}
         	createParseTable(&why);
         	struct grammar G;
         	loadGrammar(&G,"grammar.txt") ;        
         	
         	
              		struct ParseTree* roottree = parseInputSourceCode(STARTNODE,&why,&G);
              		if(yourOption == 4)
              		{
                  		FILE *outfile = fopen(argv[2],"w");
				printtree(roottree);
                   		printParseTree(roottree,outfile);

              		}             
         	

           } 
        }
     }
   }
   else
    printf("Wrong Input");  			 
  printf("\n Program Finished");

}
